/******************************************************************************
  indexing.c:
  =============

    reindexing of Kohn-Sham Hamiltonian from filename.scfout, for make interfaces
    e.g Xatu code.

    N. N. Batista
    nnardoto@gmail.com
    17/Jun./2024
    
    Adaptation of analysis_example.c from openmx@3.9 code
    https://www.openmx-square.org/	

  
*******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "read_scfout.h"
#include "indexing.h"


int** aIndex;
int Index(int l, int m, int n)
{
    return Map[N + l][N + m] - 1;
}

void Clear()
{
    // verificar se é só isso mesmo
    for(int i = 0; i < 2*N + 1; i++)
    {
        free(Map[i]);
    }
    free(Map);
}

void MakeMap()
{
    N = 0; 
    for (int GlobalA = 1; GlobalA <= atomnum; GlobalA++)
    {
        for (int LocalB = 0; LocalB <= FNAN[GlobalA]; LocalB++)
        {
            int Rn = ncn[GlobalA][LocalB];
      
            for(int i = 0; i < 3; i++)
            {
                if(N < abs(atv_ijk[Rn][i + 1]))
                {
                    N = abs(atv_ijk[Rn][i + 1]);
                }
            }
        }
    } 

    // Alloca memoria para indexação
    Map = malloc((2*N + 1) * sizeof(int*));
    for(int i = 0; i < 2*N + 1; i++)
    {
        Map[i] = malloc((2*N + 1) * sizeof(int));
        for(int j = 0; j < 2*N + 1; j++)
        {
            Map[i][j] = 0;
        }
    }

    // Verifica quais matrizes existem
    nMat = 0;
    for (int GlobalA = 1; GlobalA <= atomnum; GlobalA++)
    {
        for (int LocalB = 0; LocalB <= FNAN[GlobalA]; LocalB++)
        {
            int Rn = ncn[GlobalA][LocalB];
            int l, m, n;
            l = atv_ijk[Rn][1];
            m = atv_ijk[Rn][2];
            
            Map[N + l][N + m] = 1;
        }
    } 

    // indexa corretamente
    for(int i = -N; i <= N; i++)
    {
        for(int j = -N; j <= N; j++)
        {
            if(Map[N + i][N + j])
            {
                nMat += 1;
                Map[N + i][N + j] = nMat;
            }
        }
    }

    // preenche a indexação reversa
    aIndex = malloc(nMat * sizeof(int*));
    for(int i = 0; i < nMat; i++)
    {
        aIndex[i] = malloc(3 * sizeof(int));
        aIndex[i][0] = 0;
        aIndex[i][1] = 0;
        aIndex[i][2] = 0;
    }
}

void Export2TBX(char* SystemName)
{
    static int i,j,tnoA,tnoB,Anum,Bnum,NUM,GA_AN,LB_AN,GB_AN;
    static int l1,l2,l3,Rn;
    int MP[atomnum];
    int Dimension = 2;

    double ***H, ***S;
    
    Anum = 1;
    for (i=1; i<=atomnum; i++){
        MP[i] = Anum;
        Anum += Total_NumOrbs[i];
    }
    NUM = Anum - 1;
    MSize = NUM;

    // Aloca memoria
    H = malloc(nMat * sizeof(double*));
    S = malloc(nMat * sizeof(double*));
    for(int nn = 0; nn < nMat; nn++)
    {
        H[nn] = malloc(NUM * sizeof(double*));
        S[nn] = malloc(NUM * sizeof(double*));    
        for(int i = 0; i < NUM; i++)
        {
            H[nn][i] = malloc(NUM * sizeof(double));
            S[nn][i] = malloc(NUM * sizeof(double));
        }
    }

    // inicializa com zeros 
    for(int nn = 0; nn < nMat; nn++)
    {
        for(int i = 0; i < NUM; i++)
        {
            for(int j = 0; j < NUM; j++)
            {
                H[nn][i][j] = 0.0;
                S[nn][i][j] = 0.0;
            }
        }
    }


    // Reindex Hamiltonian
    ExtractHamiltonian(H, Hks[0]);
    ExtractOverlap(S, OLP);

    // create xatu file
    FILE* HFile = fopen("hamiltonian.dat", "w");
    FILE* SFile = fopen("overlap.dat"    , "w");

    // Heads
    fprintf(HFile, "Hamiltonian: File Generated by openmx2tbx Code\n");
    fprintf(SFile, "Overlap: File Generated by openmx2tbx Code\n");

    fprintf(HFile, "% 8i\n", MSize);
    fprintf(SFile, "% 8i\n", MSize);


    fprintf(HFile, "% 8i\n", nMat);
    fprintf(SFile, "% 8i\n", nMat);

    for(int i = 0; i < nMat / 15; i++)
    {
        for(int j = 0; j < 15; j++)
        {
            fprintf(HFile, "% 3i  ", 1);
            fprintf(SFile, "% 3i  ", 1);
        }
        fprintf(HFile, "\n");
        fprintf(SFile, "\n");
    }

    for(int j = 0; j < nMat % 15; j++)
    {
        fprintf(HFile, "% 3i  ", 1);
        fprintf(SFile, "% 3i  ", 1);
    }
    
    fprintf(HFile, "\n");
    fprintf(SFile, "\n");

    for(int nn = 0; nn < nMat; nn++)                                            
    {                                                                           
        for(int i = 0; i < NUM; i++)                                            
        {                                                                       
            for(int j = 0; j < NUM; j++)                                        
            {                                                                   
                int Rx, Ry, Rz;
                Rx = aIndex[nn][0];
                Ry = aIndex[nn][1];
                Rz = 0;
                fprintf(HFile, "% 3i  % 3i  % 3i  %3i  %3i    % 12.8lf  % 12.8lf    \n", Rx, Ry, Rz, i+1, j+1, H[nn][i][j], 0.0);       
                fprintf(SFile, "% 3i  % 3i  % 3i  %3i  %3i    % 12.8lf  % 12.8lf    \n", Rx, Ry, Rz, i+1, j+1, S[nn][i][j], 0.0);       
            }                                                                   
        } 
    }

    fclose(HFile);
    fclose(SFile);
}                                                                           

void ExtractOverlap(double ***NewOverlap, double ****Overlap)
{
    static int i,j,tnoA,tnoB,Anum,Bnum,NUM,GA_AN,LB_AN,GB_AN;
    static int l1,l2,l3,Rn;
    int MP[atomnum];

    // Size of Matrices
    Anum = 1;
    for (i = 1; i <= atomnum; i++)
    {
        MP[i] = Anum;
        Anum += Total_NumOrbs[i];
    }

    NUM = Anum - 1;

    /****************************************************
                           set overlap
    ****************************************************/
    for (GA_AN=1; GA_AN<=atomnum; GA_AN++)
    {
        tnoA = Total_NumOrbs[GA_AN];
        Anum = MP[GA_AN];

        for (LB_AN=0; LB_AN<=FNAN[GA_AN]; LB_AN++)
        {
            GB_AN = natn[GA_AN][LB_AN];
            Rn = ncn[GA_AN][LB_AN];
            tnoB = Total_NumOrbs[GB_AN];

            l1 = atv_ijk[Rn][1];
            l2 = atv_ijk[Rn][2];
            l3 = atv_ijk[Rn][3];

            Bnum = MP[GB_AN];
            for (i=0; i<tnoA; i++)
            {
   	            for (j=0; j<tnoB; j++)
   	            {
                    NewOverlap[Index(l1, l2, l3)][Anum + i - 1][Bnum + j - 1] = OLP[GA_AN][LB_AN][i][j];
   	            }
            }
        }
    }
}

void ExtractHamiltonian(double ***NewHH, double ****RH)
{
    static int i,j,tnoA,tnoB,Anum,Bnum,NUM,GA_AN,LB_AN,GB_AN;
    static int l1,l2,l3,Rn;
    int MP[atomnum];

    Anum = 1;
    for (i=1; i<=atomnum; i++)
    {
        MP[i] = Anum;
        Anum += Total_NumOrbs[i];
    }
    NUM = Anum - 1;


    /****************************************************
                        set Hamiltonian
    ****************************************************/

    for (GA_AN=1; GA_AN<=atomnum; GA_AN++)
    {
        tnoA = Total_NumOrbs[GA_AN];
        Anum = MP[GA_AN];

        for (LB_AN=0; LB_AN<=FNAN[GA_AN]; LB_AN++)
        {
            GB_AN = natn[GA_AN][LB_AN];
            Rn = ncn[GA_AN][LB_AN];
            tnoB = Total_NumOrbs[GB_AN];

            l1 = atv_ijk[Rn][1];
            l2 = atv_ijk[Rn][2];
            l3 = atv_ijk[Rn][3];

            Bnum = MP[GB_AN];
            for (i=0; i<tnoA; i++)
            {
                for (j=0; j<tnoB; j++)
                {
                    NewHH[Index(l1, l2, l3)][Anum + i - 1][Bnum + j - 1] = ToEV*RH[GA_AN][LB_AN][i][j];
                    aIndex[Index(l1, l2, l3)][0] = l1;
                    aIndex[Index(l1, l2, l3)][1] = l2;
                    aIndex[Index(l1, l2, l3)][2] = l3;
                } 
            } 
        }
    }
}
